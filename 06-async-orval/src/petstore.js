/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 * OpenAPI spec version: 1.0.7
 */
export interface ApiResponse {
  code?: number;
  type?: string;
  message?: string;
}

export interface Category {
  id?: number;
  name?: string;
}

/**
 * pet status in the store
 */
export type PetStatus = typeof PetStatus[keyof typeof PetStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PetStatus = {
  available: 'available',
  pending: 'pending',
  sold: 'sold',
} as const;

export interface Pet {
  id?: number;
  category?: Category;
  name: string;
  photoUrls: string[];
  tags?: Tag[];
  /** pet status in the store */
  status?: PetStatus;
}

export interface Tag {
  id?: number;
  name?: string;
}

/**
 * Order Status
 */
export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderStatus = {
  placed: 'placed',
  approved: 'approved',
  delivered: 'delivered',
} as const;

export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: string;
  /** Order Status */
  status?: OrderStatus;
  complete?: boolean;
}

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /** User Status */
  userStatus?: number;
}

/**
 * List of user object
 */
export type UserArrayBody = User[];

/**
 * Pet object that needs to be added to the store
 */
export type PetBody = Pet;

export type UploadFileBody = {
  /** Additional data to pass to server */
  additionalMetadata?: string;
  /** file to upload */
  file?: Blob;
};

export type FindPetsByStatusParams = {
/**
 * Status values that need to be considered for filter
 */
status: FindPetsByStatusStatusItem[];
};

export type FindPetsByStatusStatusItem = typeof FindPetsByStatusStatusItem[keyof typeof FindPetsByStatusStatusItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindPetsByStatusStatusItem = {
  available: 'available',
  pending: 'pending',
  sold: 'sold',
} as const;

export type FindPetsByTagsParams = {
/**
 * Tags to filter by
 */
tags: string[];
};

export type UpdatePetWithFormBody = {
  /** Updated name of the pet */
  name?: string;
  /** Updated status of the pet */
  status?: string;
};

export type GetInventory200 = {[key: string]: number};

export type LoginUserParams = {
/**
 * The user name for login
 */
username: string;
/**
 * The password for login in clear text
 */
password: string;
};



/**
 * @summary uploads an image
 */
export type uploadFileResponse = {
  data: ApiResponse;
  status: number;
  headers: Headers;
}

export const getUploadFileUrl = (petId: number,) => {


  return `/pet/${petId}/uploadImage`
}

export const uploadFile = async (petId: number,
    uploadFileBody: UploadFileBody, options?: RequestInit): Promise<uploadFileResponse> => {
    const formData = new FormData();
if(uploadFileBody.additionalMetadata !== undefined) {
 formData.append('additionalMetadata', uploadFileBody.additionalMetadata)
 }
if(uploadFileBody.file !== undefined) {
 formData.append('file', uploadFileBody.file)
 }

  const res = await fetch(getUploadFileUrl(petId),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: uploadFileResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as uploadFileResponse
}



/**
 * @summary Add a new pet to the store
 */
export type addPetResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAddPetUrl = () => {


  return `/pet`
}

export const addPet = async (petBody: PetBody, options?: RequestInit): Promise<addPetResponse> => {
  
  const res = await fetch(getAddPetUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      petBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: addPetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as addPetResponse
}



/**
 * @summary Update an existing pet
 */
export type updatePetResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getUpdatePetUrl = () => {


  return `/pet`
}

export const updatePet = async (petBody: PetBody, options?: RequestInit): Promise<updatePetResponse> => {
  
  const res = await fetch(getUpdatePetUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      petBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updatePetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updatePetResponse
}



/**
 * Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 */
export type findPetsByStatusResponse = {
  data: Pet[] | void;
  status: number;
  headers: Headers;
}

export const getFindPetsByStatusUrl = (params: FindPetsByStatusParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["status"];
      
    if (value instanceof Array && explodeParameters.includes(key)) {
      value.forEach((v) => normalizedParams.append(key, v === null ? 'null' : v.toString()));
      return;
    }
      
    
  });

  return normalizedParams.size ? `/pet/findByStatus?${normalizedParams.toString()}` : `/pet/findByStatus`
}

export const findPetsByStatus = async (params: FindPetsByStatusParams, options?: RequestInit): Promise<findPetsByStatusResponse> => {
  
  const res = await fetch(getFindPetsByStatusUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findPetsByStatusResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findPetsByStatusResponse
}



/**
 * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @deprecated
 * @summary Finds Pets by tags
 */
export type findPetsByTagsResponse = {
  data: Pet[] | void;
  status: number;
  headers: Headers;
}

export const getFindPetsByTagsUrl = (params: FindPetsByTagsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["tags"];
      
    if (value instanceof Array && explodeParameters.includes(key)) {
      value.forEach((v) => normalizedParams.append(key, v === null ? 'null' : v.toString()));
      return;
    }
      
    
  });

  return normalizedParams.size ? `/pet/findByTags?${normalizedParams.toString()}` : `/pet/findByTags`
}

export const findPetsByTags = async (params: FindPetsByTagsParams, options?: RequestInit): Promise<findPetsByTagsResponse> => {
  
  const res = await fetch(getFindPetsByTagsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findPetsByTagsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findPetsByTagsResponse
}



/**
 * Returns a single pet
 * @summary Find pet by ID
 */
export type getPetByIdResponse = {
  data: Pet | void;
  status: number;
  headers: Headers;
}

export const getGetPetByIdUrl = (petId: number,) => {


  return `/pet/${petId}`
}

export const getPetById = async (petId: number, options?: RequestInit): Promise<getPetByIdResponse> => {
  
  const res = await fetch(getGetPetByIdUrl(petId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPetByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPetByIdResponse
}



/**
 * @summary Updates a pet in the store with form data
 */
export type updatePetWithFormResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getUpdatePetWithFormUrl = (petId: number,) => {


  return `/pet/${petId}`
}

export const updatePetWithForm = async (petId: number,
    updatePetWithFormBody: UpdatePetWithFormBody, options?: RequestInit): Promise<updatePetWithFormResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updatePetWithFormBody.name !== undefined) {
 formUrlEncoded.append('name', updatePetWithFormBody.name)
 }
if(updatePetWithFormBody.status !== undefined) {
 formUrlEncoded.append('status', updatePetWithFormBody.status)
 }

  const res = await fetch(getUpdatePetWithFormUrl(petId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updatePetWithFormResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updatePetWithFormResponse
}



/**
 * @summary Deletes a pet
 */
export type deletePetResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getDeletePetUrl = (petId: number,) => {


  return `/pet/${petId}`
}

export const deletePet = async (petId: number, options?: RequestInit): Promise<deletePetResponse> => {
  
  const res = await fetch(getDeletePetUrl(petId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deletePetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deletePetResponse
}



/**
 * Returns a map of status codes to quantities
 * @summary Returns pet inventories by status
 */
export type getInventoryResponse = {
  data: GetInventory200;
  status: number;
  headers: Headers;
}

export const getGetInventoryUrl = () => {


  return `/store/inventory`
}

export const getInventory = async ( options?: RequestInit): Promise<getInventoryResponse> => {
  
  const res = await fetch(getGetInventoryUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getInventoryResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getInventoryResponse
}



/**
 * @summary Place an order for a pet
 */
export type placeOrderResponse = {
  data: Order | void;
  status: number;
  headers: Headers;
}

export const getPlaceOrderUrl = () => {


  return `/store/order`
}

export const placeOrder = async (order: Order, options?: RequestInit): Promise<placeOrderResponse> => {
  
  const res = await fetch(getPlaceOrderUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      order,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: placeOrderResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as placeOrderResponse
}



/**
 * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions
 * @summary Find purchase order by ID
 */
export type getOrderByIdResponse = {
  data: Order | void;
  status: number;
  headers: Headers;
}

export const getGetOrderByIdUrl = (orderId: number,) => {


  return `/store/order/${orderId}`
}

export const getOrderById = async (orderId: number, options?: RequestInit): Promise<getOrderByIdResponse> => {
  
  const res = await fetch(getGetOrderByIdUrl(orderId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOrderByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getOrderByIdResponse
}



/**
 * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
 * @summary Delete purchase order by ID
 */
export type deleteOrderResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getDeleteOrderUrl = (orderId: number,) => {


  return `/store/order/${orderId}`
}

export const deleteOrder = async (orderId: number, options?: RequestInit): Promise<deleteOrderResponse> => {
  
  const res = await fetch(getDeleteOrderUrl(orderId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteOrderResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteOrderResponse
}



/**
 * @summary Creates list of users with given input array
 */
export type createUsersWithListInputResponse = {
  data: void | void;
  status: number;
  headers: Headers;
}

export const getCreateUsersWithListInputUrl = () => {


  return `/user/createWithList`
}

export const createUsersWithListInput = async (userArrayBody: UserArrayBody, options?: RequestInit): Promise<createUsersWithListInputResponse> => {
  
  const res = await fetch(getCreateUsersWithListInputUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userArrayBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createUsersWithListInputResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createUsersWithListInputResponse
}



/**
 * @summary Get user by user name
 */
export type getUserByNameResponse = {
  data: User | void;
  status: number;
  headers: Headers;
}

export const getGetUserByNameUrl = (username: string,) => {


  return `/user/${username}`
}

export const getUserByName = async (username: string, options?: RequestInit): Promise<getUserByNameResponse> => {
  
  const res = await fetch(getGetUserByNameUrl(username),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getUserByNameResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getUserByNameResponse
}



/**
 * This can only be done by the logged in user.
 * @summary Updated user
 */
export type updateUserResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getUpdateUserUrl = (username: string,) => {


  return `/user/${username}`
}

export const updateUser = async (username: string,
    user: User, options?: RequestInit): Promise<updateUserResponse> => {
  
  const res = await fetch(getUpdateUserUrl(username),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      user,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateUserResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateUserResponse
}



/**
 * This can only be done by the logged in user.
 * @summary Delete user
 */
export type deleteUserResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getDeleteUserUrl = (username: string,) => {


  return `/user/${username}`
}

export const deleteUser = async (username: string, options?: RequestInit): Promise<deleteUserResponse> => {
  
  const res = await fetch(getDeleteUserUrl(username),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteUserResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteUserResponse
}



/**
 * @summary Logs user into the system
 */
export type loginUserResponse = {
  data: string | void;
  status: number;
  headers: Headers;
}

export const getLoginUserUrl = (params: LoginUserParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/user/login?${normalizedParams.toString()}` : `/user/login`
}

export const loginUser = async (params: LoginUserParams, options?: RequestInit): Promise<loginUserResponse> => {
  
  const res = await fetch(getLoginUserUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: loginUserResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as loginUserResponse
}



/**
 * @summary Logs out current logged in user session
 */
export type logoutUserResponse = {
  data: void | void;
  status: number;
  headers: Headers;
}

export const getLogoutUserUrl = () => {


  return `/user/logout`
}

export const logoutUser = async ( options?: RequestInit): Promise<logoutUserResponse> => {
  
  const res = await fetch(getLogoutUserUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: logoutUserResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as logoutUserResponse
}



/**
 * @summary Creates list of users with given input array
 */
export type createUsersWithArrayInputResponse = {
  data: void | void;
  status: number;
  headers: Headers;
}

export const getCreateUsersWithArrayInputUrl = () => {


  return `/user/createWithArray`
}

export const createUsersWithArrayInput = async (userArrayBody: UserArrayBody, options?: RequestInit): Promise<createUsersWithArrayInputResponse> => {
  
  const res = await fetch(getCreateUsersWithArrayInputUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userArrayBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createUsersWithArrayInputResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createUsersWithArrayInputResponse
}



/**
 * This can only be done by the logged in user.
 * @summary Create user
 */
export type createUserResponse = {
  data: void | void;
  status: number;
  headers: Headers;
}

export const getCreateUserUrl = () => {


  return `/user`
}

export const createUser = async (user: User, options?: RequestInit): Promise<createUserResponse> => {
  
  const res = await fetch(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      user,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createUserResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createUserResponse
}



